---
title: "Multidimensional RoPE"
description: "Non-Axial Rotary Positional Embeddings in higher dimensions."
date: 2025-07-31
image: 
    path: assets/img/golden_rope.png
    alt: "Visualization of Golden RoPE"
    hide: true
comments: false
toc: false
categories: [Machine Learning]
tags: [transformers, positional embeddings, math, visualization]
math: true
---

I was recently part of some cool discussions in an ML research group chat about extending [rotary positional embeddings](https://arxiv.org/abs/2104.09864)[^rope-paper] for transformers to higher dimensions. This post highlights some of the ideas that came out of it, the initial idea being a that attention scores of rope in 2D should be isotropic unlike the widely used Axial RoPE[^axial-rope]. Hence, a non-axial variant for 2D was proposed.

People are calling it Golden RoPE, Uniform RoPE, or IsotRoPE. 

Most of the credit goes to [jerry](https://jerryxio.ng/), who also wrote a great post about it[^jerrys-post].

---

[Kevin Yin](https://my-astro-app.kyinmath-cf.workers.dev/) wrote a follow-up appendix to jerry's post, attributing most of the success to incoherent angles instead of angle uniformity[^kevins-post].

---

[Nor](https://nor-blog.pages.dev/) has a great post on deriving RoPE the proper way with 3 very reasonable constraints[^nor-post]:

1.  **Relative position dependency**:
    $$ \langle f(q, p_q), f(k, p_k) \rangle = g(q, k, p_q - p_k) $$

2.  **Norm preservation**:
    $$ \|f(q, p_q)\| = \|q\| $$

3.  **Linearity**:
    $$ f(q, p_q) = M(p_q)q $$

---

You should read jerry's blog[^jerrys-post] to get the full picture, but the tldr is that given a block-diagonal rotation matrix for $D$-dimensional keys and queries

$$
\mathrm{RoPE}_{\boldsymbol{\theta}} =
\begin{bmatrix}
R_0(\theta_0) & 0 & \cdots & 0 \\
0 & R_1(\theta_1) & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & R_{D/2-1}(\theta_{D/2-1})
\end{bmatrix}
$$

we replace the axial rope rotations[^rotation-matrix]


$$
\begin{cases}
R_i(\omega_ix) & \text{if } i \text{ is even} \\
R_i(\omega_iy) & \text{if } i \text{ is odd}
\end{cases}
$$


with a rotation matrix of the form

$$R_i(\omega_i\langle \boldsymbol{u_i}, \boldsymbol{p}\rangle)$$

- $\boldsymbol{u_i} \in \mathbb{R}^2$ are unit vectors evenly spaced around the unit circle by an angle of $\Delta u$ (i.e. $\boldsymbol{u_i} = R_{\Delta u}\boldsymbol{u_{i-1}}$)
- $\boldsymbol{p} \in \mathbb{R}^2$ is the position
- $\omega_i$ is the $i$-th frequency magnitude

<!-- <div class="aside"> -->
---

Notice how in the visualization below, a $\Delta u$ of $\frac{\pi}{2}$ appears to give us axial rope, but this is not really true! We are also cycling over negative $x$ and $y$, which axial rope never does.

Since we're using the same random unit vectors for keys and queries pre-rotation, the $\sin$ cross-term vanishes. Given that, and $\cos$ being symmetric, our $(\pm x,0),\;(0,\pm y)$ cycle simplifies to $(x,0),\;(0,y)$.


So unlike RoPE in practice, we can ignore the squared norm and the $\sin$ cross-term. This is intentional for the visualization.


<details>
<summary><b>WARNING: unnecessary notation abuse</b></summary>

i.e. if we look at just a single pair of $q :=\boldsymbol{Q}_{xy}$ and $k :=\boldsymbol{K}_{xy}$, we get:

$$
\begin{aligned}

q = k \implies
% \mathrm{score}(q, k) &= 
\langle R(\theta_q)q,\ R(\theta_k)k \rangle
&= \langle R(\theta_q)q,\ R(\theta_q + \Delta\theta)q \rangle \\[4px]
&= q^\top R(\Delta\theta)\,q \\[4px]
% \qquad(\Delta\theta:=\theta_q-\theta_k)\\[4px]
&= \|q\|^2 \cos(\Delta\theta) + 
\underbrace{(q_x q_y - q_y q_x)}_{\text{vanishes}}\sin(\Delta\theta) \\[4px]
% (q_x q_y - q_y q_x)\sin(\Delta\theta) \\[4px]
&= \|q\|^2 \cos(\Delta\theta) \qquad \text{since $q$ is a unit vector} \\[4px]
&= \cos(\Delta\theta) = \cos(-\Delta\theta) \\[4px]
\end{aligned}

$$

</details>

<!-- </div> -->

---

Play with the spacing to see how the attention scores change. Try $[\pi\frac{\sqrt5-1}{2}] \mathrm{mod}\,\pi \approx$ 1.9414[^kevins-post].


[^jerrys-post]: [jerryxio's post](https://jerryxio.ng/posts/nd-rope/)
[^kevins-post]: [Kevin Yin's post](https://my-astro-app.kyinmath-cf.workers.dev/blog/rope/)
[^nor-post]: [Nor's post](https://nor-blog.pages.dev/posts/2025-07-28-deriving-rope/)
[^rope-paper]: [RoPE paper](https://arxiv.org/abs/2104.09864)
[^axial-rope]: [Heo et al. 2024](https://arxiv.org/abs/2403.13298) attributes axial rope to [Fang et al. 2023](https://arxiv.org/abs/2303.11331).
[^rotation-matrix]: $R_i(\theta)$ is the $2\times2$ rotation matrix acting on dimensions $[2i, 2i+1]$ of the keys and queries.


<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  .rope-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    margin-top: 20px;
    gap: 20px;
  }
  .controls-panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 220px;
    text-align: left;
    font-family: sans-serif;
  }
  .control-group {
    display: flex;
    flex-direction: column;
  }
  .control-group label {
    margin-bottom: 5px;
    font-weight: bold;
    font-size: 0.9em;
    color: var(--text-color);
  }
  .input-slider-group {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .input-slider-group input[type="number"] {
    width: 60px;
    text-align: right;
    background-color: var(--main-bg-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
  }
  /* Custom Range Slider Styles */
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 4px;
        background: var(--button-bg);
        border-radius: 5px;
        outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: var(--text-color);
        cursor: pointer;
        border-radius: 50%;
    }

    input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: var(--text-color);
        cursor: pointer;
        border-radius: 50%;
        border: none;
    }
  #tooltip {
    position: fixed; /* Use fixed positioning */
    display: none;
    background: rgba(0, 0, 0, 0.4);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: sans-serif;
    pointer-events: none;
  }
  #animate-phi-button, #reset-button {
      width: 100%;
      padding: 8px;
      font-weight: bold;
      background-color: var(--button-bg);
      border: 1px solid var(--button-border-color);
      color: var(--button-text-color);
      border-radius: 5px;
      cursor: pointer;
  }
  .button-group {
      display: flex;
  }
  .button-group button {
      flex-grow: 1;
  }
  .button-group button:hover {
      background-color: var(--button-hover-bg);
  }
  .button-group button:first-child {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      border-right: 0.5px solid var(--button-border-color);
  }
  .button-group button:last-child {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left: 0.5px solid var(--button-border-color);
  }
</style>

<div class="rope-container">
  <canvas id="rope-canvas" width="400" height="400" style="border:1px solid var(--border-color); border-radius: 5px; background-color: white; image-rendering: pixelated;"></canvas>
  <div class="controls-panel">
    <div class="control-group">
      <label for="res-input">Resolution</label>
      <div class="input-slider-group">
        <input type="number" id="res-input" min="9" max="101" value="69" step="2">
        <input type="range" id="res-slider" min="9" max="101" value="69" step="2">
      </div>
    </div>
    <div class="control-group">
      <label for="n-freqs-input">Num Frequencies</label>
      <div class="input-slider-group">
        <input type="number" id="n-freqs-input" min="1" max="256" value="256" step="1">
        <input type="range" id="n-freqs-slider" min="1" max="256" value="256" step="1">
      </div>
    </div>
    <div class="control-group">
      <label for="min-freq-input">Min Freq.</label>
      <div class="input-slider-group">
        <input type="number" id="min-freq-input" min="0.01" max="50" value="0.58" step="0.01">
        <input type="range" id="min-freq-slider" min="0" max="100" value="0">
      </div>
    </div>
    <div class="control-group">
      <label for="max-freq-input">Max Freq.</label>
      <div class="input-slider-group">
        <input type="number" id="max-freq-input" min="1" max="1000" value="125.9" step="0.1">
        <input type="range" id="max-freq-slider" min="0" max="100" value="0">
      </div>
    </div>
    <div class="control-group">
        <label for="phi-spacing-input">Direction Spacing (Î”u)</label>
        <div class="input-slider-group">
            <input type="number" id="phi-spacing-input" min="0" max="3.1415" value="1.5708" step="0.0001">
            <input type="range" id="phi-spacing-slider" min="0" max="31415" value="15708">
        </div>
    </div>
    <div class="control-group" style="display: none;">
      <label for="center-x-input">Center X</label>
      <div class="input-slider-group">
        <input type="number" id="center-x-input" value="0" step="1">
        <input type="range" id="center-x-slider" value="0" step="1">
      </div>
    </div>
    <div class="control-group" style="display: none;">
      <label for="center-y-input">Center Y</label>
      <div class="input-slider-group">
        <input type="number" id="center-y-input" value="0" step="1">
        <input type="range" id="center-y-slider" value="0" step="1">
      </div>
    </div>
    <div class="control-group">
        <div class="button-group">
            <button id="animate-phi-button">Play</button>
            <button id="reset-button">Reset</button>
        </div>
    </div>
    <div id="speed-control-group" class="control-group" style="display: none;">
        <label for="speed-slider">Animation Speed</label>
        <div class="input-slider-group">
            <input type="range" id="speed-slider" min="1" max="100" value="6">
        </div>
    </div>
  </div>
  <div id="tooltip"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const resSlider = document.getElementById('res-slider');
    const nFreqsSlider = document.getElementById('n-freqs-slider');
    const minFreqSlider = document.getElementById('min-freq-slider');
    const maxFreqSlider = document.getElementById('max-freq-slider');
    const phiSpacingSlider = document.getElementById('phi-spacing-slider');
    const animatePhiButton = document.getElementById('animate-phi-button');
    const resetButton = document.getElementById('reset-button');
    const speedSlider = document.getElementById('speed-slider');
    const speedControlGroup = document.getElementById('speed-control-group');
    const centerXSlider = document.getElementById('center-x-slider');
    const centerYSlider = document.getElementById('center-y-slider');

    const resInput = document.getElementById('res-input');
    const nFreqsInput = document.getElementById('n-freqs-input');
    const minFreqInput = document.getElementById('min-freq-input');
    const maxFreqInput = document.getElementById('max-freq-input');
    const phiSpacingInput = document.getElementById('phi-spacing-input');
    const centerXInput = document.getElementById('center-x-input');
    const centerYInput = document.getElementById('center-y-input');
    
    const ropeCanvas = document.getElementById('rope-canvas');
    const ropeCtx = ropeCanvas.getContext('2d');
    ropeCtx.imageSmoothingEnabled = false;
    
    const min_log_min = Math.log10(0.01);
    const min_log_max = Math.log10(50);
    const max_log_min = Math.log10(1);
    const max_log_max = Math.log10(1000);
    
    const color = d3.scaleSequential(d3.interpolateCubehelixDefault).domain([-1, 1]);
    let currentData = null;
    let currentRes = 0;
    let animationFrameId = null;

    function updateCenterSliders() {
        const res = parseInt(resInput.value, 10);
        const halfRes = Math.floor(res / 2);

        centerXSlider.min = -halfRes;
        centerXSlider.max = halfRes;
        centerXInput.min = -halfRes;
        centerXInput.max = halfRes;

        centerYSlider.min = -halfRes;
        centerYSlider.max = halfRes;
        centerYInput.min = -halfRes;
        centerYInput.max = halfRes;
        
        const currentX = parseInt(centerXInput.value, 10);
        const currentY = parseInt(centerYInput.value, 10);

        centerXInput.value = Math.max(-halfRes, Math.min(halfRes, currentX));
        centerYInput.value = Math.max(-halfRes, Math.min(halfRes, currentY));
        centerXSlider.value = centerXInput.value;
        centerYSlider.value = centerYInput.value;
    }

    function linspace(a, b, n) {
        if (n < 2) return n === 1 ? [a] : [];
        const arr = new Array(n);
        const step = (b - a) / (n - 1);
        for (let i = 0; i < n; i++) arr[i] = a + i * step;
        return arr;
    }

    function computeAlignment(N, minFreq, maxFreq, nFreqs, phiSpacing, refX, refY) {
        const hh = linspace(-1, 1, N);
        const ww = linspace(-1, 1, N);
        
        const refX_norm = ww[refX + Math.floor(N/2)];
        const refY_norm = hh[refY + Math.floor(N/2)];
        
        const B = 8;

        const freqs = new Float64Array(nFreqs * 2);
        for (let f = 0; f < nFreqs; f++) {
            const phi = f * phiSpacing;
            const dx = Math.cos(phi);
            const dy = Math.sin(phi);
            const scale = minFreq * Math.pow(maxFreq / minFreq, nFreqs === 1 ? 0 : f / (nFreqs - 1));
            freqs[2 * f] = dx * scale;
            freqs[2 * f + 1] = dy * scale;
        }

        const align = new Float64Array(N * N);
        for (let i = 0; i < N; i++) {
            const posY = hh[i];
            for (let j = 0; j < N; j++) {
                const posX = ww[j];
                let sum = 0;

                for (let f = 0; f < nFreqs; f++) {
                    const fx = freqs[2 * f];
                    const fy = freqs[2 * f + 1];
                    const theta_pos = fx * posX + fy * posY;
                    const theta_ref = fx * refX_norm + fy * refY_norm;
                    const delta_theta = theta_pos - theta_ref;
                    const c = Math.cos(delta_theta);

                    for (let b = 0; b < B; b++) {
                        sum += c;
                    }
                }
                align[i * N + j] = Math.max(0, sum / (B * nFreqs));
            }
        }
        return align;
    }

    function drawRope() {
        let res = parseInt(resInput.value, 10);
        const nFreqs = parseInt(nFreqsInput.value, 10);
        const min_freq = parseFloat(minFreqInput.value);
        const max_freq = parseFloat(maxFreqInput.value);
        const phi_spacing = parseFloat(phiSpacingInput.value);
        const centerX = parseInt(centerXInput.value, 10);
        const centerY = parseInt(centerYInput.value, 10);
        
        currentRes = res;
        currentData = computeAlignment(res, min_freq, max_freq, nFreqs, phi_spacing, centerX, centerY);

        const img = ropeCtx.createImageData(res, res);
        for (let i = 0; i < currentData.length; i++) {
            const c = d3.rgb(color(currentData[i]));
            img.data[i * 4] = c.r;
            img.data[i * 4 + 1] = c.g;
            img.data[i * 4 + 2] = c.b;
            img.data[i * 4 + 3] = 255;
        }
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = res;
        tempCanvas.height = res;
        tempCanvas.getContext('2d').putImageData(img, 0, 0);

        ropeCtx.clearRect(0, 0, ropeCanvas.width, ropeCanvas.height);
        ropeCtx.drawImage(tempCanvas, 0, 0, ropeCanvas.width, ropeCanvas.height);
    }

    function updateFromSliders() {
        resInput.value = resSlider.value;
        if (parseInt(resInput.value, 10) !== currentRes) {
            updateCenterSliders();
        }
        nFreqsInput.value = nFreqsSlider.value;
        minFreqInput.value = Math.pow(10, min_log_min + (minFreqSlider.value/100) * (min_log_max - min_log_min)).toFixed(2);
        maxFreqInput.value = Math.pow(10, max_log_min + (maxFreqSlider.value/100) * (max_log_max - max_log_min)).toFixed(1);
        phiSpacingInput.value = (phiSpacingSlider.value / 10000).toFixed(4);
        centerXInput.value = centerXSlider.value;
        centerYInput.value = centerYSlider.value;
        drawRope();
    }
    
    function updateFromInputs(){
        resSlider.value = resInput.value;
        if (parseInt(resInput.value, 10) !== currentRes) {
            updateCenterSliders();
        }
        nFreqsSlider.value = nFreqsInput.value;
        minFreqSlider.value = 100 * (Math.log10(minFreqInput.value) - min_log_min) / (min_log_max - min_log_min);
        maxFreqSlider.value = 100 * (Math.log10(maxFreqInput.value) - max_log_min) / (max_log_max - max_log_min);
        phiSpacingSlider.value = phiSpacingInput.value * 10000;
        centerXSlider.value = centerXInput.value;
        centerYSlider.value = centerYInput.value;
        drawRope();
    }
    
    function setInitialValues() {
        resInput.value = 69;
        nFreqsInput.value = 256;
        minFreqInput.value = 0.58;
        maxFreqInput.value = 125.9;
        phiSpacingInput.value = 1.5708;
        centerXInput.value = 0;
        centerYInput.value = 0;
        updateCenterSliders();
        updateFromInputs();
    }
    
    function animatePhi() {
        let currentValue = parseInt(phiSpacingSlider.value, 10);
        currentValue += parseInt(speedSlider.value, 10);
        if (currentValue > parseInt(phiSpacingSlider.max, 10)) {
            currentValue = 0;
        }
        phiSpacingSlider.value = currentValue;
        updateFromSliders();
        animationFrameId = requestAnimationFrame(animatePhi);
    }

    animatePhiButton.addEventListener('click', () => {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            animatePhiButton.textContent = 'Play';
            speedControlGroup.style.display = 'none';
        } else {
            animatePhi();
            animatePhiButton.textContent = 'Cancel';
            speedControlGroup.style.display = 'block';
        }
    });

    resetButton.addEventListener('click', setInitialValues);

    [resSlider, nFreqsSlider, minFreqSlider, maxFreqSlider, phiSpacingSlider, centerXSlider, centerYSlider].forEach(s => s.addEventListener('input', updateFromSliders));
    [resInput, nFreqsInput, minFreqInput, maxFreqInput, phiSpacingInput, centerXInput, centerYInput].forEach(i => i.addEventListener('change', updateFromInputs));
    
    const tooltip = d3.select("#tooltip");
    ropeCanvas.addEventListener("mousemove", (e) => {
        if (!currentData) return;
        const rect = ropeCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) * (currentRes / rect.width));
        const y = Math.floor((e.clientY - rect.top) * (currentRes / rect.height));
        if (x < 0 || x >= currentRes || y < 0 || y >= currentRes) {
            tooltip.style("display", "none");
            return;
        }
        const v = currentData[y * currentRes + x];
        tooltip
            .style("left", `${e.clientX + 10}px`)
            .style("top", `${e.clientY + 10}px`)
            .style("display", "block")
            .text(`(${x - Math.floor(currentRes/2)}, ${y - Math.floor(currentRes/2)}): ${v.toFixed(4)}`);
    });
    ropeCanvas.addEventListener("mouseleave", () => tooltip.style("display", "none"));

    setInitialValues();
});
</script>
