---
title: "Multidimensional RoPE"
description: "Non-Axial Rotary Positional Embeddings in higher dimensions."
date: 2025-07-31
image: 
    path: assets/img/golden_rope.png
    alt: "Visualization of Golden RoPE"
    hide: true
comments: false
toc: false
categories: [Machine Learning]
math: true
---

I was recently part of some cool discussions in an ML research group chat about extending [rotary positional embeddings](https://arxiv.org/abs/2104.09864) for transformers to higher dimensions. This post highlights some of the ideas that came out of it, the initial idea being a that attention scores of rope in 2D should be isotropic. Hence, a non-[axial](https://arxiv.org/abs/1912.12180) variant for 2D. 

People are calling it Golden RoPE, Uniform RoPE, or IsotRoPE. 

Most of the credit goes to [jerryxio](https://jerryxio.ng/posts/nd-rope/), who also wrote a great post about it.

---

[Kevin Yin](https://my-astro-app.kyinmath-cf.workers.dev/blog/rope/) wrote a follow-up appendix to jerry's post, attributing most of the success to incoherent angles instead of angle uniformity.

---

[Nor](https://nor-blog.pages.dev/posts/2025-07-28-deriving-rope/) has a great post on deriving RoPE the proper way with 3 very reasonable constraints:

1.  **Relative position dependency**:
    $$ \langle f(q, p_q), f(k, p_k) \rangle = g(q, k, p_q - p_k) $$

2.  **Norm preservation**:
    $$ \|f(q, p_q)\| = \|q\| $$

3.  **Linearity**:
    $$ f(q, p_q) = M(p_q)q $$

---

You should read jerry's blog to get the full picture, but the tldr is that we replace the axial rope rotations 

$$
\begin{cases}
R_i(\omega_ix) & \text{if } i \text{ is even} \\
R_i(\omega_iy) & \text{if } i \text{ is odd}
\end{cases}
$$

in the $i$-th block of the block-diagonal rope matrix with 

$$R_i(\omega_i\langle \boldsymbol{u_i}, \boldsymbol{p}\rangle)$$

- $\boldsymbol{u_i} \in \mathbb{R}^2$ are unit vectors evenly spaced around the unit circle by an angle of $\Delta u$ (i.e. $\boldsymbol{u_i} = R_{\Delta u}\boldsymbol{u_{i-1}}$)
- $\boldsymbol{p} \in \mathbb{R}^2$ is the position
- $\omega_i$ is the $i$-th frequency magnitude

Notice how a $\Delta u$ of $\frac{\pi}{2}$ actually gives us axial rope because the unit vectors are aligned with the axes, this is what you see in the visualization below. 

---

Play with the spacing to see how the attention scores change. Try using the golden ratio (1.618).



<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  .rope-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    margin-top: 20px;
    gap: 20px;
  }
  .controls-panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 220px;
    text-align: left;
    font-family: sans-serif;
  }
  .control-group {
    display: flex;
    flex-direction: column;
  }
  .control-group label {
    margin-bottom: 5px;
    font-weight: bold;
    font-size: 0.9em;
    color: var(--text-color);
  }
  .input-slider-group {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .input-slider-group input[type="number"] {
    width: 60px;
    text-align: right;
    background-color: var(--main-bg-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 5px;
  }
  /* Custom Range Slider Styles */
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 4px;
        background: var(--button-bg);
        border-radius: 5px;
        outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: var(--text-color);
        cursor: pointer;
        border-radius: 50%;
    }

    input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: var(--text-color);
        cursor: pointer;
        border-radius: 50%;
        border: none;
    }
  #tooltip {
    position: fixed; /* Use fixed positioning */
    display: none;
    background: rgba(0, 0, 0, 0.4);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: sans-serif;
    pointer-events: none;
  }
  #animate-phi-button {
      width: 100%;
      padding: 8px;
      font-weight: bold;
      background-color: var(--button-bg);
      border: 1px solid var(--button-border-color);
      color: var(--button-text-color);
      border-radius: 5px;
      cursor: pointer;
  }
  #animate-phi-button:hover {
      background-color: var(--button-hover-bg);
  }
</style>

<div class="rope-container">
  <canvas id="rope-canvas" width="400" height="400" style="border:1px solid var(--border-color); border-radius: 5px; background-color: white; image-rendering: pixelated;"></canvas>
  <div class="controls-panel">
    <div class="control-group">
      <label for="res-input">Resolution</label>
      <div class="input-slider-group">
        <input type="number" id="res-input" min="9" max="101" value="69" step="2">
        <input type="range" id="res-slider" min="9" max="101" value="69" step="2">
      </div>
    </div>
    <div class="control-group">
      <label for="n-freqs-input">Num Frequencies</label>
      <div class="input-slider-group">
        <input type="number" id="n-freqs-input" min="1" max="256" value="128" step="1">
        <input type="range" id="n-freqs-slider" min="1" max="256" value="128" step="1">
      </div>
    </div>
    <div class="control-group">
      <label for="min-freq-input">Min Freq.</label>
      <div class="input-slider-group">
        <input type="number" id="min-freq-input" min="0.01" max="50" value="0.58" step="0.01">
        <input type="range" id="min-freq-slider" min="0" max="100" value="0">
      </div>
    </div>
    <div class="control-group">
      <label for="max-freq-input">Max Freq.</label>
      <div class="input-slider-group">
        <input type="number" id="max-freq-input" min="1" max="1000" value="125.9" step="0.1">
        <input type="range" id="max-freq-slider" min="0" max="100" value="0">
      </div>
    </div>
    <div class="control-group">
        <label for="phi-spacing-input">Direction Spacing (Î”u)</label>
        <div class="input-slider-group">
            <input type="number" id="phi-spacing-input" min="0" max="3.1415" value="1.5708" step="0.0001">
            <input type="range" id="phi-spacing-slider" min="0" max="31415" value="15708">
        </div>
    </div>
    <div class="control-group">
        <button id="animate-phi-button">Play</button>
    </div>
    <div id="speed-control-group" class="control-group" style="display: none;">
        <label for="speed-slider">Animation Speed</label>
        <div class="input-slider-group">
            <input type="range" id="speed-slider" min="1" max="100" value="6">
        </div>
    </div>
  </div>
  <div id="tooltip"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const resSlider = document.getElementById('res-slider');
    const nFreqsSlider = document.getElementById('n-freqs-slider');
    const minFreqSlider = document.getElementById('min-freq-slider');
    const maxFreqSlider = document.getElementById('max-freq-slider');
    const phiSpacingSlider = document.getElementById('phi-spacing-slider');
    const animatePhiButton = document.getElementById('animate-phi-button');
    const speedSlider = document.getElementById('speed-slider');
    const speedControlGroup = document.getElementById('speed-control-group');

    const resInput = document.getElementById('res-input');
    const nFreqsInput = document.getElementById('n-freqs-input');
    const minFreqInput = document.getElementById('min-freq-input');
    const maxFreqInput = document.getElementById('max-freq-input');
    const phiSpacingInput = document.getElementById('phi-spacing-input');
    
    const ropeCanvas = document.getElementById('rope-canvas');
    const ropeCtx = ropeCanvas.getContext('2d');
    ropeCtx.imageSmoothingEnabled = false;
    
    const min_log_min = Math.log10(0.01);
    const min_log_max = Math.log10(50);
    const max_log_min = Math.log10(1);
    const max_log_max = Math.log10(1000);
    
    const color = d3.scaleSequential(d3.interpolateCubehelixDefault).domain([-1, 1]);
    let currentData = null;
    let currentRes = 0;
    let animationFrameId = null;

    function cyrb128(str) {
        let h1 = 1779033703, h2 = 3144134277,
            h3 = 1013904242, h4 = 2773480762;
        for (let i = 0, k; i < str.length; i++) {
            k = str.charCodeAt(i);
            h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
            h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
            h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
            h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
        }
        h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
        h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
        h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
        h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
        h1 ^= (h2 ^ h3 ^ h4); h2 ^= h1; h3 ^= h1; h4 ^= h1;
        return [h1 >>> 0, h2 >>> 0, h3 >>> 0, h4 >>> 0];
    }
    
    function sfc32(a, b, c, d) {
        return function () {
            a |= 0; b |= 0; c |= 0; d |= 0;
            let t = (a + b | 0) + d | 0;
            d = d + 1 | 0;
            a = b ^ b >>> 9;
            b = c + (c << 3) | 0;
            c = (c << 21 | c >>> 11);
            c = c + t | 0;
            return (t >>> 0) / 4294967296;
        }
    }

    function linspace(a, b, n) {
        if (n < 2) return n === 1 ? [a] : [];
        const arr = new Array(n);
        const step = (b - a) / (n - 1);
        for (let i = 0; i < n; i++) arr[i] = a + i * step;
        return arr;
    }

    function computeAlignment(N, minFreq, maxFreq, nFreqs, phiSpacing) {
        const hh = linspace(-1, 1, N);
        const ww = linspace(-1, 1, N);
        
        let seed = cyrb128("constant_seed");
        let rand = sfc32(seed[0], seed[1], seed[2], seed[3]);
        function randn() {
            let u = 0, v = 0;
            while (u === 0) u = rand();
            while (v === 0) v = rand();
            return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        }

        const B = 8;
        const dataVecs = new Float64Array(B * nFreqs * 2);
        for (let i = 0; i < dataVecs.length; i++) {
            dataVecs[i] = randn();
        }

        const freqs = new Float64Array(nFreqs * 2);
        for (let f = 0; f < nFreqs; f++) {
            const phi = f * phiSpacing;
            const dx = Math.cos(phi);
            const dy = Math.sin(phi);
            const scale = minFreq * Math.pow(maxFreq / minFreq, nFreqs === 1 ? 0 : f / (nFreqs - 1));
            freqs[2 * f] = dx * scale;
            freqs[2 * f + 1] = dy * scale;
        }

        const align = new Float64Array(N * N);
        for (let i = 0; i < N; i++) {
            const posY = hh[i];
            for (let j = 0; j < N; j++) {
                const posX = ww[j];
                let sum = 0;

                for (let f = 0; f < nFreqs; f++) {
                    const fx = freqs[2 * f];
                    const fy = freqs[2 * f + 1];
                    const theta = fx * posX + fy * posY;
                    const c = Math.cos(theta);
                    const s = Math.sin(theta);

                    for (let b = 0; b < B; b++) {
                        const idx = (b * nFreqs + f) * 2;
                        const x = dataVecs[idx];
                        const y = dataVecs[idx + 1];
                        const xOut = x * c - y * s;
                        const yOut = x * s + y * c;
                        sum += xOut * x + yOut * y;
                    }
                }
                align[i * N + j] = Math.max(0, sum / (B * nFreqs * 2));
            }
        }
        return align;
    }

    function drawRope() {
        let res = parseInt(resInput.value, 10);
        const nFreqs = parseInt(nFreqsInput.value, 10);
        const min_freq = parseFloat(minFreqInput.value);
        const max_freq = parseFloat(maxFreqInput.value);
        const phi_spacing = parseFloat(phiSpacingInput.value);
        
        currentRes = res;
        currentData = computeAlignment(res, min_freq, max_freq, nFreqs, phi_spacing);

        const img = ropeCtx.createImageData(res, res);
        for (let i = 0; i < currentData.length; i++) {
            const c = d3.rgb(color(currentData[i]));
            img.data[i * 4] = c.r;
            img.data[i * 4 + 1] = c.g;
            img.data[i * 4 + 2] = c.b;
            img.data[i * 4 + 3] = 255;
        }
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = res;
        tempCanvas.height = res;
        tempCanvas.getContext('2d').putImageData(img, 0, 0);

        ropeCtx.clearRect(0, 0, ropeCanvas.width, ropeCanvas.height);
        ropeCtx.drawImage(tempCanvas, 0, 0, ropeCanvas.width, ropeCanvas.height);
    }

    function updateFromSliders() {
        resInput.value = resSlider.value;
        nFreqsInput.value = nFreqsSlider.value;
        minFreqInput.value = Math.pow(10, min_log_min + (minFreqSlider.value/100) * (min_log_max - min_log_min)).toFixed(2);
        maxFreqInput.value = Math.pow(10, max_log_min + (maxFreqSlider.value/100) * (max_log_max - max_log_min)).toFixed(1);
        phiSpacingInput.value = (phiSpacingSlider.value / 10000).toFixed(4);
        drawRope();
    }
    
    function updateFromInputs(){
        resSlider.value = resInput.value;
        nFreqsSlider.value = nFreqsInput.value;
        minFreqSlider.value = 100 * (Math.log10(minFreqInput.value) - min_log_min) / (min_log_max - min_log_min);
        maxFreqSlider.value = 100 * (Math.log10(maxFreqInput.value) - max_log_min) / (max_log_max - max_log_min);
        phiSpacingSlider.value = phiSpacingInput.value * 10000;
        drawRope();
    }
    
    function setInitialValues() {
        resInput.value = 69;
        nFreqsInput.value = 128;
        minFreqInput.value = 0.58;
        maxFreqInput.value = 125.9;
        phiSpacingInput.value = 1.5708;
        updateFromInputs();
    }
    
    function animatePhi() {
        let currentValue = parseInt(phiSpacingSlider.value, 10);
        currentValue += parseInt(speedSlider.value, 10);
        if (currentValue > parseInt(phiSpacingSlider.max, 10)) {
            currentValue = 0;
        }
        phiSpacingSlider.value = currentValue;
        updateFromSliders();
        animationFrameId = requestAnimationFrame(animatePhi);
    }

    animatePhiButton.addEventListener('click', () => {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            animatePhiButton.textContent = 'Play';
            speedControlGroup.style.display = 'none';
        } else {
            animatePhi();
            animatePhiButton.textContent = 'Cancel';
            speedControlGroup.style.display = 'block';
        }
    });

    [resSlider, nFreqsSlider, minFreqSlider, maxFreqSlider, phiSpacingSlider].forEach(s => s.addEventListener('input', updateFromSliders));
    [resInput, nFreqsInput, minFreqInput, maxFreqInput, phiSpacingInput].forEach(i => i.addEventListener('change', updateFromInputs));
    
    const tooltip = d3.select("#tooltip");
    ropeCanvas.addEventListener("mousemove", (e) => {
        if (!currentData) return;
        const rect = ropeCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) * (currentRes / rect.width));
        const y = Math.floor((e.clientY - rect.top) * (currentRes / rect.height));
        if (x < 0 || x >= currentRes || y < 0 || y >= currentRes) {
            tooltip.style("display", "none");
            return;
        }
        const v = currentData[y * currentRes + x];
        tooltip
            .style("left", `${e.clientX + 10}px`)
            .style("top", `${e.clientY + 10}px`)
            .style("display", "block")
            .text(`(${x - Math.floor(currentRes/2)}, ${y - Math.floor(currentRes/2)}): ${v.toFixed(4)}`);
    });
    ropeCanvas.addEventListener("mouseleave", () => tooltip.style("display", "none"));

    setInitialValues();
});
</script>

